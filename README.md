# Time-Complexity-of-Merge-And-Insertion-Sort
# Tasks:
# Task 1:
• Implementation of a function InsertionSort that takes array A and sort the array. Function should
have the following prototype.
• void InsertionSort(int array[], int start, int end)
• Implement a function that takes the array and populate the array with random numbers.
o void RandomArray(int array[], int size)
• Also calculate the time, that InsertionSort function takes. Print the answer in seconds.
• Save the sorted array in SortedInsertionSort.csv. One integer at one line.
# Task 2:
• Implementation of a function MergeSort that takes array A and sort the array. Function should
have the following prototype.
o void MergeSort(int array[], int start, int end)
o void Merge(int array[], int p, int q, int r)
• Also calculate the time, that InsertionSort function takes. Print the answer in seconds.
• Save the sorted array in SortedMergeSort.csv. One integer at one line.
# Task 3:
Use the value of n to create the hybrid Merge sort in which instead of dividing arrays to single
element array, divide the array to the value of n, so that small arrays can be sorted using insertion
sort.
• Implement a function HybridMergeSort that takes array A and sort the array. Function
should have the following prototype.
o void HybridMergeSort(int array[], int start, int end)
• Save the sorted array in SortedHybridSort.csv. One integer at one line.
